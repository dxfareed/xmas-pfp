import { NextRequest, NextResponse } from "next/server";
import { isAuthenticated } from "@/lib/auth";
import { withRetry } from "@/lib/retry";
import axios from 'axios';
import prisma from "@/lib/prisma";
import { z } from 'zod';

// Define a schema for the incoming request body
const mintRequestSchema = z.object({
  imageData: z.string(),
  txHash: z.string(),
});

async function uploadToPinata(imageData: string, fid: number) {
  const pinataApiKey = process.env.PINATA_API_KEY!;
  const pinataSecretApiKey = process.env.PINATA_API_SECRET!;

  const imageBuffer = Buffer.from(imageData.split(",")[1], "base64");
  const imageBlob = new Blob([imageBuffer], { type: "image/png" });

  const form = new FormData();
  form.append("file", imageBlob, `ReligiousWarplet_${fid}_${Date.now()}.png`);
  form.append("pinataMetadata", JSON.stringify({ name: `ReligiousWarplet Image for FID ${fid}` }));
  form.append("pinataOptions", JSON.stringify({ cidVersion: 1 }));

  const pinFileResponse = await axios.post("https://api.pinata.cloud/pinning/pinFileToIPFS", form, {
    headers: {
      'pinata_api_key': pinataApiKey,
      'pinata_secret_api_key': pinataSecretApiKey,
    },
  });

  const { IpfsHash: imageIpfsHash } = pinFileResponse.data;
  const imageUrl = `ipfs://${imageIpfsHash}`;

  const metadata = {
    name: "Religious Warplet",
    description: "A unique piece of religious art generated for the holder.",
    image: imageUrl,
    attributes: [{ trait_type: "Generated By", value: `FID: ${fid}` }],
  };
  
  const pinMetadataResponse = await axios.post("https://api.pinata.cloud/pinning/pinJSONToIPFS", {
      pinataContent: metadata,
      pinataMetadata: { name: `ReligiousWarplet_Metadata_${fid}_${Date.now()}.json` },
      pinataOptions: { cidVersion: 1 }
  }, {
    headers: {
      'Content-Type': 'application/json',
      'pinata_api_key': pinataApiKey,
      'pinata_secret_api_key': pinataSecretApiKey,
    }
  });

  const { IpfsHash: metadataIpfsHash } = pinMetadataResponse.data;
  const tokenUri = `ipfs://${metadataIpfsHash}`;
  
  return { tokenUri, imageUrl };
}

export async function POST(request: NextRequest) {
  if (!process.env.PINATA_API_KEY || !process.env.PINATA_API_SECRET) {
    return NextResponse.json({ message: "Server configuration error: Missing Pinata credentials." }, { status: 500 });
  }

  const fid = await isAuthenticated(request);
  if (fid instanceof NextResponse) {
    return fid;
  }

  const body = await request.json();
  const validation = mintRequestSchema.safeParse(body);

  if (!validation.success) {
    return NextResponse.json({ message: "Invalid request body", errors: validation.error.errors }, { status: 400 });
  }

  const { imageData, txHash } = validation.data;

  try {
    const { tokenUri, imageUrl } = await withRetry(() => uploadToPinata(imageData, fid));

    const newNft = {
      imageUrl,
      tokenUri,
      txHash,
      mintedAt: new Date().toISOString(),
    };

    await withRetry(async () => {
      const userNfts = await prisma.userNFTs.findUnique({
        where: { ownerFid: BigInt(fid) },
      });

      if (userNfts) {
        const updatedNfts = [...(userNfts.nfts as any[]), newNft];
        await prisma.userNFTs.update({
          where: { ownerFid: BigInt(fid) },
          data: { nfts: updatedNfts },
        });
      } else {
        await prisma.userNFTs.create({
          data: {
            ownerFid: BigInt(fid),
            nfts: [newNft],
          },
        });
      }
    });

    return NextResponse.json({ tokenUri, imageUrl }, { status: 200 });
  } catch (error) {
    console.error("Error during mint process:", error);
    const errorMessage = error instanceof Error ? error.message : "An unknown error occurred.";
    return NextResponse.json({ message: `Error: ${errorMessage}` }, { status: 500 });
  }
}